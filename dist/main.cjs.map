{"version":3,"sources":["../../signals/src/main.ts","../src/main.ts"],"names":["currentEffect","signal","initialValue","value","subscribers","read","write","newValue","fn","update","peek","subscribe","sig","effect","cleanup","isDisposed","execute","prevEffect","result","disposer","computed","currentContext","contexts","setHookContext","context","getHook","index","hook","setHook","useState","initial","v","action","useEffect","callback","deps","dep","i","useMemo","factory","newHook","useCallback","useRef","ref","useSignal","useComputed","comp","b","useReducer","reducer","initialState","state","setState","prev","prevValue","createContext","defaultValue","useContext","ContextProvider","props","useToggle","usePrevious","useCounter","count","setCount","useLocalStorage","key","stored","useDebounce","delay","debouncedValue","setDebouncedValue","timer","useInterval","savedCallback","id","useWindowSize","size","setSize","handleResize","useMediaQuery","query","matches","setMatches","media","listener","e","useEventListener","eventName","handler","element","savedHandler","event","main_default"],"mappings":"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","file":"main.cjs","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\r\n// src/main.ts\r\n//\r\n// Made with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import { Signal, EffectCleanup, Computed } from './types';\r\n    export type * from './types';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\r\n\r\n    let currentEffect       : (() => void)   | null = null;\r\n    let currentRoot         : (() => void)[] | null = null;\r\n    let batchDepth          : number                = 0;\r\n    const batchedEffects    : Set<() => void>       = new Set<() => void>();\r\n    const flushedEffects    : Set<() => void>       = new Set<() => void>();\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    /**\r\n     * Creates a reactive signal that can be read, written, and subscribed to.\r\n     * @template T - The type of value stored in the signal\r\n     * @param {T} initialValue - The initial value of the signal\r\n     * @returns {Signal<T>} A signal object with read, set, update, peek, and subscribe methods\r\n     * @example\r\n     * const count = signal(0);\r\n     * console.log(count()); // 0\r\n     * count.set(5); // Update value\r\n     */\r\n    export function signal<T>(initialValue: T): Signal<T> {\r\n        let value           = initialValue;\r\n        const subscribers   = new Set<() => void>();\r\n\r\n        function read(): T {\r\n            // Track dependency if inside effect\r\n            if (currentEffect) {\r\n                subscribers.add(currentEffect);\r\n            }\r\n            return value;\r\n        }\r\n\r\n        function write(newValue: T): void {\r\n            // Only update if value actually changed\r\n            if (Object.is(value, newValue)) return;\r\n\r\n            value = newValue;\r\n\r\n            // Notify all subscribers\r\n            if (batchDepth > 0) {\r\n                // Batch mode: collect effects\r\n                subscribers.forEach(fn => batchedEffects.add(fn));\r\n            } else {\r\n                // Immediate mode: run effects now\r\n                subscribers.forEach(fn => fn());\r\n            }\r\n        }\r\n\r\n        function update(fn: (prev: T) => T): void {\r\n            write(fn(value));\r\n        }\r\n\r\n        function peek(): T {\r\n            // Read without tracking\r\n            return value;\r\n        }\r\n\r\n        function subscribe(fn: () => void): () => void {\r\n            subscribers.add(fn);\r\n            return () => subscribers.delete(fn);\r\n        }\r\n\r\n        // Create signal function with methods\r\n        const sig = read as Signal<T>;\r\n        sig.set = write;\r\n        sig.update = update;\r\n        sig.peek = peek;\r\n        sig.subscribe = subscribe;\r\n\r\n        return sig;\r\n    }\r\n\r\n    /**\r\n     * Automatically runs a function when its signal dependencies change.\r\n     * @param {() => EffectCleanup} fn - The effect function to run. Can optionally return a cleanup function.\r\n     * @returns {() => void} A dispose function to stop the effect and clean up\r\n     * @example\r\n     * const count = signal(0);\r\n     * effect(() => {\r\n     *   console.log('Count:', count());\r\n     *   return () => console.log('Cleaning up');\r\n     * });\r\n     */\r\n    export function effect(fn: () => EffectCleanup): () => void {\r\n        let cleanup: (() => void) | undefined;\r\n        let isDisposed = false;\r\n\r\n        const execute = () => {\r\n            if (isDisposed) return;\r\n\r\n            // Run cleanup from previous execution\r\n            if (cleanup) {\r\n                cleanup();\r\n                cleanup = undefined;\r\n            }\r\n\r\n            // Set as current effect for dependency tracking\r\n            const prevEffect = currentEffect;\r\n            currentEffect = execute;\r\n\r\n            try {\r\n                // Run the effect function\r\n                const result = fn();\r\n\r\n                // Store cleanup if returned\r\n                if (typeof result === 'function') {\r\n                    cleanup = result;\r\n                }\r\n            } finally {\r\n                // Restore previous effect\r\n                currentEffect = prevEffect;\r\n            }\r\n        };\r\n\r\n        // Run immediately\r\n        execute();\r\n\r\n        // Create dispose function\r\n        const disposer = () => {\r\n            if (isDisposed) return;\r\n            isDisposed = true;\r\n            if (cleanup) cleanup();\r\n        };\r\n\r\n        // Register with current root if one exists\r\n        if (currentRoot) {\r\n            currentRoot.push(disposer);\r\n        }\r\n\r\n        // Return dispose function\r\n        return disposer;\r\n    }\r\n\r\n    /**\r\n     * Creates a computed signal that automatically updates when its dependencies change.\r\n     * The computation result is cached and only recomputed when dependencies change.\r\n     * @template T - The type of value computed\r\n     * @param {() => T} fn - The computation function\r\n     * @returns {Computed<T>} A read-only computed signal\r\n     * @example\r\n     * const count = signal(5);\r\n     * const doubled = computed(() => count() * 2);\r\n     * console.log(doubled()); // 10\r\n     */\r\n    export function computed<T>(fn: () => T): Computed<T> {\r\n        const sig = signal<T>(undefined as T);\r\n\r\n        // Create effect that updates the signal\r\n        effect(() => {\r\n            sig.set(fn());\r\n        });\r\n\r\n        // Mark as computed\r\n        const computed = sig as Computed<T>;\r\n        Object.defineProperty(computed, 'isComputed', {\r\n            value: true,\r\n            writable: false\r\n        });\r\n\r\n        return computed;\r\n    }\r\n\r\n    /**\r\n     * Groups multiple signal updates together, deferring effect execution until all updates complete.\r\n     * This improves performance by preventing cascading effect runs.\r\n     * @template T - The return type of the function\r\n     * @param {() => T} fn - A function that performs multiple signal updates\r\n     * @returns {T} The return value of the function\r\n     * @example\r\n     * const a = signal(1);\r\n     * const b = signal(2);\r\n     * batch(() => {\r\n     *   a.set(10);\r\n     *   b.set(20);\r\n     * }); // Effects only run once\r\n     */\r\n    export function batch<T>(fn: () => T): T {\r\n        batchDepth++;\r\n\r\n        try {\r\n            return fn();\r\n        } finally {\r\n            batchDepth--;\r\n\r\n            // If we're back at depth 0, flush batched effects\r\n            if (batchDepth === 0) {\r\n                // Keep batch mode active while flushing to prevent cascading effects\r\n                batchDepth++;\r\n                flushedEffects.clear();\r\n                try {\r\n                    // Keep running effects until no more are queued\r\n                    while (batchedEffects.size > 0) {\r\n                        const effects = Array.from(batchedEffects);\r\n                        batchedEffects.clear();\r\n                        effects.forEach(fn => {\r\n                            // Only run if we haven't run it in this batch\r\n                            if (!flushedEffects.has(fn)) {\r\n                                flushedEffects.add(fn);\r\n                                fn();\r\n                            }\r\n                        });\r\n                    }\r\n                } finally {\r\n                    batchDepth--;\r\n                    flushedEffects.clear();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reads signals without creating dependencies on them.\r\n     * Useful for accessing signal values without triggering effect re-runs.\r\n     * @template T - The return type of the function\r\n     * @param {() => T} fn - A function that accesses signals\r\n     * @returns {T} The return value of the function\r\n     * @example\r\n     * const count = signal(0);\r\n     * effect(() => {\r\n     *   const value = untrack(() => count()); // Won't trigger re-run\r\n     *   console.log(value);\r\n     * });\r\n     */\r\n    export function untrack<T>(fn: () => T): T {\r\n        const prevEffect = currentEffect;\r\n        currentEffect = null;\r\n\r\n        try {\r\n            return fn();\r\n        } finally {\r\n            currentEffect = prevEffect;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs an effect only when a specific signal changes, providing both new and previous values.\r\n     * @template T - The type of the signal\r\n     * @param {Signal<T>} sig - The signal to watch\r\n     * @param {(value: T, prevValue: T) => EffectCleanup} fn - Effect function called with new and previous values\r\n     * @returns {() => void} A dispose function to stop watching\r\n     * @example\r\n     * const count = signal(0);\r\n     * on(count, (newVal, oldVal) => {\r\n     *   console.log(`Changed from ${oldVal} to ${newVal}`);\r\n     * });\r\n     */\r\n    export function on<T>(\r\n        sig: Signal<T>,\r\n        fn: (value: T, prevValue: T) => EffectCleanup\r\n    ): () => void {\r\n        let prevValue = sig.peek();\r\n\r\n        return effect(() => {\r\n            // Read the signal to create dependency\r\n            const value = sig();\r\n\r\n            // Run callback without tracking new dependencies\r\n            const cleanup = untrack(() => fn(value, prevValue));\r\n            prevValue = value;\r\n            return cleanup;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a store object where each property is a signal.\r\n     * Provides a convenient way to manage multiple related reactive values.\r\n     * @template T - The type of the initial state object\r\n     * @param {T} initialState - An object with initial values\r\n     * @returns {{ [K in keyof T]: Signal<T[K]> }} An object with signals for each property\r\n     * @example\r\n     * const state = store({ count: 0, name: 'John' });\r\n     * console.log(state.count()); // 0\r\n     * state.name.set('Jane');\r\n     */\r\n    export function store<T extends Record<string, any>>(\r\n        initialState: T\r\n    ): { [K in keyof T]: Signal<T[K]> } {\r\n        const store = {} as any;\r\n\r\n        for (const key in initialState) {\r\n            store[key] = signal(initialState[key]);\r\n        }\r\n\r\n        return store;\r\n    }\r\n\r\n    /**\r\n     * Memoizes the result of an expensive computation, caching it indefinitely.\r\n     * Unlike computed, this doesn't depend on reactive signals.\r\n     * @template T - The type of the memoized value\r\n     * @param {() => T} fn - A function that performs the computation\r\n     * @returns {() => T} A function that returns the cached result\r\n     * @example\r\n     * const expensiveCalc = memo(() => {\r\n     *   return Array.from({ length: 1000 }).map(expensiveOp);\r\n     * });\r\n     * const result = expensiveCalc(); // Computed only once\r\n     */\r\n    export function memo<T>(fn: () => T): () => T {\r\n        let cachedValue: T | undefined;\r\n        let hasCachedValue = false;\r\n\r\n        return () => {\r\n            if (hasCachedValue) {\r\n                return cachedValue as T;\r\n            }\r\n\r\n            // Compute the value\r\n            const value = fn();\r\n\r\n            // Cache it\r\n            cachedValue = value;\r\n            hasCachedValue = true;\r\n\r\n            return value;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates a root scope for managing effect and computed signal lifecycles.\r\n     * All effects and disposers created within the function are collected and can be cleaned up together.\r\n     * @template T - The return type of the function\r\n     * @param {(dispose: () => void) => T} fn - A function that receives a dispose function\r\n     * @returns {T} The return value of the function\r\n     * @example\r\n     * const dispose = root((dispose) => {\r\n     *   effect(() => console.log('Running'));\r\n     *   return 42;\r\n     * });\r\n     * dispose(); // Cleans up all effects created in the root\r\n     */\r\n    export function root<T>(fn: (dispose: () => void) => T): T {\r\n        const disposers: (() => void)[] = [];\r\n        const prevRoot = currentRoot;\r\n        currentRoot = disposers;\r\n\r\n        try {\r\n            const dispose = () => {\r\n                disposers.forEach(d => d());\r\n                disposers.length = 0;\r\n                currentRoot = prevRoot;\r\n            };\r\n\r\n            return fn(dispose);\r\n        } finally {\r\n            currentRoot = prevRoot;\r\n        }\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ HELP ════════════════════════════════════════╗\r\n\r\n    /**\r\n     * Development utilities for debugging signal reactivity\r\n     */\r\n    export const dev = {\r\n        /**\r\n         * Returns the currently executing effect, or null if no effect is running\r\n         * @returns {(() => void) | null} The current effect function or null\r\n         */\r\n        getCurrentEffect(): (() => void) | null {\r\n            return currentEffect;\r\n        },\r\n\r\n        /**\r\n         * Returns the current batch depth (for debugging nested batch calls)\r\n         * @returns {number} The current batch nesting level\r\n         */\r\n        getBatchDepth(): number {\r\n            return batchDepth;\r\n        },\r\n\r\n        /**\r\n         * Returns the count of effects currently pending in the batch queue\r\n         * @returns {number} The number of batched effects waiting to run\r\n         */\r\n        getBatchedEffectsCount(): number {\r\n            return batchedEffects.size;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Type guard to check if a value is a signal\r\n     * @template T - The type of value the signal contains\r\n     * @param {any} value - The value to check\r\n     * @returns {boolean} True if the value is a signal\r\n     * @example\r\n     * if (isSignal(myValue)) {\r\n     *   console.log(myValue());\r\n     * }\r\n     */\r\n    export function isSignal<T>(value: any): value is Signal<T> {\r\n        return (\r\n            typeof value === 'function' &&\r\n            'set' in value &&\r\n            'update' in value &&\r\n            'peek' in value\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Type guard to check if a value is a computed signal\r\n     * @template T - The type of value the computed signal contains\r\n     * @param {any} value - The value to check\r\n     * @returns {boolean} True if the value is a computed signal\r\n     * @example\r\n     * if (isComputed(myValue)) {\r\n     *   console.log('This is a computed signal');\r\n     * }\r\n     */\r\n    export function isComputed<T>(value: any): value is Computed<T> {\r\n        return isSignal(value) && 'isComputed' in value;\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ ════ ════════════════════════════════════════╗\r\n\r\n    export default {\r\n        signal,\r\n        effect,\r\n        computed,\r\n        batch,\r\n        untrack,\r\n        on,\r\n        store,\r\n        memo,\r\n        root,\r\n        isSignal,\r\n        isComputed,\r\n        dev\r\n    };\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n// src/main.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { signal, computed, type Signal } from '@minejs/signals';\n    import type * as types from './types';\n    export type * from './types';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    let currentContext: types.HookContext | null = null;\n    const contexts = new Map<symbol, any>();\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Set current hook context (internal use)\n     */\n    export function setHookContext(context: types.HookContext | null): void {\n    currentContext = context;\n    }\n\n    /**\n     * Get current hook (internal use)\n     */\n    function getHook<T>(initialValue: T): { value: T; index: number } {\n    if (!currentContext) {\n        throw new Error('Hooks can only be called inside a component');\n    }\n\n    const index = currentContext.currentHookIndex++;\n\n    if (!currentContext.hooks[index]) {\n        currentContext.hooks[index] = { value: initialValue };\n    }\n\n    const hook = currentContext.hooks[index];\n    if (!hook || typeof hook !== 'object' || !('value' in hook)) {\n        throw new Error('Invalid hook state');\n    }\n\n    return {\n        value: (hook as { value: T }).value,\n        index\n    };\n    }\n\n    /**\n     * Update hook value (internal use)\n     */\n    function setHook(index: number, value: unknown): void {\n    if (currentContext && currentContext.hooks[index]) {\n        const hook = currentContext.hooks[index];\n        if (hook && typeof hook === 'object' && 'value' in hook) {\n            (hook as { value: unknown }).value = value;\n        }\n    }\n    }\n\n    /**\n     * Returns a stateful value and a function to update it\n     * @param initialValue - Initial state value\n     */\n    export function useState<T>(\n    initialValue: T | (() => T)\n    ): [Signal<T>, (action: types.SetStateAction<T>) => void] {\n    const hook = getHook<Signal<T> | null>(null);\n\n    // Create signal on first call\n    if (!hook.value) {\n        const initial = typeof initialValue === 'function'\n        ? (initialValue as () => T)()\n        : initialValue;\n\n        const sig = signal<T>(initial);\n        hook.value = sig;\n        setHook(hook.index, sig);\n    }\n\n    const sig = hook.value;\n\n    const setState = (action: types.SetStateAction<T>) => {\n        if (typeof action === 'function') {\n        sig.update(action as (prev: T) => T);\n        } else {\n        sig.set(action);\n        }\n    };\n\n    return [sig, setState];\n    }\n\n    /**\n     * Runs side effects after render\n     * @param callback - Effect function\n     * @param deps - Dependency array\n     */\n    export function useEffect(\n    callback: types.EffectCallback,\n    deps?: types.DependencyList\n    ): void {\n    const hook = getHook<{\n        cleanup?: () => void\n        prevDeps?: types.DependencyList\n    }>({});\n\n    // Check if deps changed\n    const depsChanged = !hook.value.prevDeps ||\n        !deps ||\n        deps.length !== hook.value.prevDeps.length ||\n        deps.some((dep, i) => !Object.is(dep, hook.value.prevDeps![i]));\n\n    if (depsChanged) {\n        // Run cleanup from previous effect\n        if (hook.value.cleanup) {\n        hook.value.cleanup();\n        }\n\n        // Run new effect\n        const cleanup = callback();\n\n        // Store cleanup and deps\n        hook.value.cleanup = cleanup || undefined;\n        hook.value.prevDeps = deps;\n        setHook(hook.index, hook.value);\n    }\n    }\n\n    /**\n     * Returns a memoized value\n     * @param factory - Function that returns value to memoize\n     * @param deps - Dependency array\n     */\n    export function useMemo<T>(\n    factory: () => T,\n    deps: types.DependencyList\n    ): T {\n    const hook = getHook<{\n        value: T\n        prevDeps: types.DependencyList\n    } | null>(null);\n\n    // Check if deps changed\n    const depsChanged = !hook.value ||\n        deps.length !== hook.value.prevDeps.length ||\n        deps.some((dep, i) => !Object.is(dep, hook.value!.prevDeps[i]));\n\n    if (depsChanged) {\n        // Recompute value\n        const value = factory();\n        const newHook = { value, prevDeps: deps };\n        setHook(hook.index, newHook);\n        return value;\n    }\n\n    return hook.value!.value;\n    }\n\n    /**\n     * Returns a memoized callback\n     * @param callback - Function to memoize\n     * @param deps - Dependency array\n     */\n    export function useCallback<T extends (...args: any[]) => any>(\n    callback: T,\n    deps: types.DependencyList\n    ): T {\n    return useMemo(() => callback, deps);\n    }\n\n    /**\n     * Returns a mutable ref object\n     * @param initialValue - Initial ref value\n     */\n    export function useRef<T>(initialValue: T): { current: T } {\n    const hook = getHook<{ current: T } | null>(null);\n\n    if (!hook.value) {\n        const ref = { current: initialValue };\n        setHook(hook.index, ref);\n        return ref;\n    }\n\n    return hook.value;\n    }\n\n    /**\n     * Create a signal (CruxJS native)\n     * @param initialValue - Initial signal value\n     */\n    export function useSignal<T>(initialValue: T): Signal<T> {\n    const hook = getHook<Signal<T> | null>(null);\n\n    if (!hook.value) {\n        const sig = signal(initialValue);\n        setHook(hook.index, sig);\n        return sig;\n    }\n\n    return hook.value;\n    }\n\n    /**\n     * Create a computed signal\n     * @param fn - Computation function\n     */\n    export function useComputed<T>(fn: () => T): Signal<T> {\n    const hook = getHook<Signal<T> | null>(null);\n\n    if (!hook.value) {\n        const comp = computed(fn);\n        setHook(hook.index, comp);\n        return comp;\n    }\n\n    return hook.value;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ ════ ════════════════════════════════════════╗\n\n    // useReducer - Reducer Hook\n\n    /**\n     * Returns state and dispatch function (like Redux)\n     * @param reducer - Reducer function\n     * @param initialState - Initial state\n     */\n    export function useReducer<S, A>(\n    reducer: types.Reducer<S, A>,\n    initialState: S\n    ): [Signal<S>, (action: A) => void] {\n    const [state, setState] = useState(initialState);\n\n    const dispatch = (action: A) => {\n        setState(prev => {\n        const prevValue = typeof prev === 'function' ? (prev as any)() : prev;\n        return reducer(prevValue, action);\n        });\n    };\n\n    return [state, dispatch];\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ ════ ════════════════════════════════════════╗\n\n    // useContext - Context Hook\n\n    /**\n     * Create a context\n     */\n    export function createContext<T>(defaultValue: T): types.Context<T> {\n    return {\n        _symbol: Symbol('context'),\n        defaultValue\n    };\n    }\n\n    /**\n     * Use context value\n     */\n    export function useContext<T>(context: types.Context<T>): T {\n    const value = contexts.get(context._symbol);\n    return value !== undefined ? value : context.defaultValue;\n    }\n\n    /**\n     * Provide context value\n     */\n    export function ContextProvider<T>(props: {\n    context: types.Context<T>\n    value: T\n    children: any\n    }): any {\n    // Store context value\n    contexts.set(props.context._symbol, props.value);\n\n    // Return children\n    return props.children;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ ════ ════════════════════════════════════════╗\n\n    // CUSTOM HOOKS - Common Patterns\n\n    /**\n     * Toggle boolean state\n     */\n    export function useToggle(initialValue = false): [Signal<boolean>, () => void] {\n    const [state, setState] = useState(initialValue);\n    const toggle = () => setState(prev => {\n        const prevValue = typeof prev === 'function' ? (prev as any)() : prev;\n        return !prevValue;\n    });\n    return [state, toggle];\n    }\n\n    /**\n     * Previous value\n     */\n    export function usePrevious<T>(value: T): T | undefined {\n    const ref = useRef<T | undefined>(undefined);\n\n    useEffect(() => {\n        ref.current = value;\n    }, [value]);\n\n    return ref.current;\n    }\n\n    /**\n     * Counter with increment/decrement\n     */\n    export function useCounter(initialValue = 0) {\n    const [count, setCount] = useState(initialValue);\n\n    return {\n        count,\n        increment: () => setCount(prev => {\n        const prevValue = typeof prev === 'function' ? (prev as any)() : prev;\n        return prevValue + 1;\n        }),\n        decrement: () => setCount(prev => {\n        const prevValue = typeof prev === 'function' ? (prev as any)() : prev;\n        return prevValue - 1;\n        }),\n        reset: () => setCount(initialValue)\n    };\n    }\n\n    /**\n     * Local storage state\n     */\n    export function useLocalStorage<T>(\n    key: string,\n    initialValue: T\n    ): [Signal<T>, (value: T) => void] {\n    // Get initial value from localStorage\n    const stored = localStorage.getItem(key);\n    const initial = stored ? JSON.parse(stored) : initialValue;\n\n    const [state, setState] = useState<T>(initial);\n\n    // Update localStorage when state changes\n    useEffect(() => {\n        localStorage.setItem(key, JSON.stringify(state()));\n    }, [state()]);\n\n    return [state, setState];\n    }\n\n    /**\n     * Debounced value\n     */\n    export function useDebounce<T>(value: T, delay: number): T {\n    const [debouncedValue, setDebouncedValue] = useState(value);\n\n    useEffect(() => {\n        const timer = setTimeout(() => {\n        setDebouncedValue(value);\n        }, delay);\n\n        return () => clearTimeout(timer);\n    }, [value, delay]);\n\n    return debouncedValue();\n    }\n\n    /**\n     * Interval hook\n     */\n    export function useInterval(callback: () => void, delay: number | null): void {\n    const savedCallback = useRef(callback);\n\n    // Remember latest callback\n    useEffect(() => {\n        savedCallback.current = callback;\n    }, [callback]);\n\n    // Set up interval\n    useEffect(() => {\n        if (delay === null) return;\n\n        const id = setInterval(() => savedCallback.current(), delay);\n        return () => clearInterval(id);\n    }, [delay]);\n    }\n\n    /**\n     * Window size\n     */\n    export function useWindowSize() {\n    const [size, setSize] = useState({\n        width: window.innerWidth,\n        height: window.innerHeight\n    });\n\n    useEffect(() => {\n        const handleResize = () => {\n        setSize({\n            width: window.innerWidth,\n            height: window.innerHeight\n        });\n        };\n\n        window.addEventListener('resize', handleResize);\n        return () => window.removeEventListener('resize', handleResize);\n    }, []);\n\n    return size();\n    }\n\n    /**\n     * Media query\n     */\n    export function useMediaQuery(query: string): boolean {\n    const [matches, setMatches] = useState(\n        () => window.matchMedia(query).matches\n    );\n\n    useEffect(() => {\n        const media = window.matchMedia(query);\n\n        const listener = (e: MediaQueryListEvent) => {\n        setMatches(e.matches);\n        };\n\n        media.addEventListener('change', listener);\n        return () => media.removeEventListener('change', listener);\n    }, [query]);\n\n    return matches();\n    }\n\n    /**\n     * Event listener\n     */\n    export function useEventListener<K extends keyof WindowEventMap>(\n    eventName: K,\n    handler: (event: WindowEventMap[K]) => void,\n    element: Window | HTMLElement = window\n    ): void {\n    const savedHandler = useRef(handler);\n\n    useEffect(() => {\n        savedHandler.current = handler;\n    }, [handler]);\n\n    useEffect(() => {\n        const listener = (event: Event) => {\n        savedHandler.current(event as WindowEventMap[K]);\n        };\n\n        element.addEventListener(eventName, listener);\n        return () => element.removeEventListener(eventName, listener);\n    }, [eventName, element]);\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ ════ ════════════════════════════════════════╗\n\n    export default {\n        // Core hooks\n        useState,\n        useEffect,\n        useMemo,\n        useCallback,\n        useRef,\n        useReducer,\n        useContext,\n\n        // CruxJS hooks\n        useSignal,\n        useComputed,\n\n        // Custom hooks\n        useToggle,\n        usePrevious,\n        useCounter,\n        useLocalStorage,\n        useDebounce,\n        useInterval,\n        useWindowSize,\n        useMediaQuery,\n        useEventListener,\n\n        // Context\n        createContext,\n        ContextProvider\n    };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n"]}